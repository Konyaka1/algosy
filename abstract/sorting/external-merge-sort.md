### Задача
Имеется массив в БД объемом, не вмещающимся в оперативную память. Нужно
отсортировать этот массив и записать в БД
### Решение
Для начала определим какие операции с БД нам доступны.
1. Достать кусок массива с любым `offest` и с `limit` не превышающим размер оперативной памяти.
2. Записать кусок массива в бд.

Вводим обозначения. 
* _N_ -- длина/размер исходного массива
* _M_ -- длина/размер оперативной памяти (максимум который мы можем взять из БД)

#### Алгоритм 1 (k-way):
1. Делим наш массив на `K = N / M (с округлением вверх)` частей. 
2. Для каждой части из пункта 1 делаем следующие действия
   1. Сортируем кусок любым способом 
   2. Записываем сортированный результат в БД (запись не перезаписывает исходный массив, БД выступает как временное хранилище).
3. Затем делим оперативную память на `K + 1` ячеек. Таким образом каждая ячейка
имеет размер `B = M / (K + 1)`. Имеем _K_ ячеек для каждой сортированной
части из предыдущего пункта и одна ячейка для вывода.
4. Далее выполняем следующий действия
   1. Загружаем в _K_ ячеек _B_ элементов из каждой сортированной части из пункта 2.
i-ая ячейка отвечает за i-ый отсортированный кусок.
   2. Ставим указатели на первый элемент каждой ячейки. Делаем след действия, пока все ячейки не пусты
      1. В ячейку вывода записываем минимальный/максимальный элемент из тех, куда указывает указатели. 
      2. Двигаем указатель ячейки в которой был минимальный/максимальный элемент на 1.
      3. Если указатель прошел всю ячейку -- загружаем в эту ячейку следующие _B_ элементов. Если больше элементов нет -- ячейка остается пустой.
      4. Как только ячейка вывода заполнена --> выгружаем ее в БД. Теперь записываем
окончательно, так мы получили _B_ отсортированных элементов.

Таким образом сортировка проходит следующим образом

```text
В скобках части отсортированы
1 pass: (Часть 1) (Часть 2) (Часть 3) ... (Часть K) 
2 pass: (Часть 1 + Часть 2 + ... + Часть K - 1 + Часть K).
```

#### Алгоритм 2 (2-way):
1. Делим наш массив на `K = N / M (с округлением вверх)` частей.
2. Затем делим оперативную память на 3 ячейки. Две ячейки для хранения 2 кусочков, и одна ячейка вывода `B = M / 3`.
3. Далее выполняем следующий действия пока `i < K / 2`. Изначально `i = 0`.
    1. Загружаем в 1 и 2 ячейки _B_ элементов из i и i + 1. Повторяем пока две ячейки не будут пустыми
       1. Ставим указатели на первый элемент каждой ячейки.
       2. В ячейку вывода записываем минимальный/максимальный элемент из тех, куда указывает указатели.
       3. Двигаем указатель ячейки в которой был минимальный/максимальный элемент на 1.
       4. Если указатель прошел всю ячейку -- загружаем в эту ячейку следующие _B_ элементов. Если больше элементов нет -- ячейка остается пустой.
       5. Как только ячейка вывода заполнена --> выгружаем вывод в БД.
    2. Выставляем i в ноль, а `K = K / 2` и повторяем действия.

Таким алгоритмом сортировка проходит следующим образом

```text
В скобках части отсортированы
1 pass: (Часть 1) (Часть 2) (Часть 3) ... (Часть K) 
2 pass: (Часть 1 + Часть 2) (Часть 2 + Часть 3) ... (Часть K - 1 + Часть K)
3 pass: (Часть 1 + Часть 2 + Часть 3 + Часть 4) ... (Часть K - 3 + Часть K - 2 + Часть K - 1 + Часть K) 
...
log K pass: (Часть 1 + Часть 2 + ... + Часть K - 1 + Часть K).
```
