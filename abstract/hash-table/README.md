## Хэш функция
Задача: отобразить _множетсво_ последовательности байт **любой длины** в _множество_ байт **фиксированный длины**.
### Виды
1) Криптографические. Устойчивы к коллизиям и к восстановлению данных из хэша.
2) Некриптографияесие. Общее назначение, высокая скорость и устойчивость к коллизиям. Нет необходимости к защите данных от восстановления по хэшу
3) Контрольные суммы. Простые функции проверяющие случайные ошибки при передаче данных. нет устойчивости к коллизиям и восстановлению/подмены данных
4) Перфектные хеш-функции. Функции на известном наборе входных значений. 100% Отсутствие коллизий.


## JWT vs MD5
MD5 **односторонняя** хэш функция, то есть невозможно восстановить данные из хэша

JWT двусторонняя функция, возможно восстановить данные имея необходимый ключ. Ключ не доступен публично, хранится на сервере выдавшем JWT.

JWT токен это строка, состоящая из `header.payload.signature`
- header -> хранит информацию о типе токена и алгоритме подписи
- payload -> закодированный json с информацией (claims) о пользователе: айди, роли и тд.
- signature -> цифровая подпись. Используется для верификации подлинности токена на сервере


## Consistent hashing
Каждый бакет в таблице отвечает за отрезок хэшей. например от 5 до 17. Все ключи имеющие хэш от 5 до 17 попадут в этот бакет.

При решардинге это позволяет экономить ресурсы на перемещение данных из бакета в бакет.

#### Пример с добавлением бакета
- Бакет_1 хранит [0, 10]
- Бакет_2 хранит [11, 30]
- Бакет_3 хранит [31, 40]
- Бакет_4 хранит [41, 50]

Мы хотим добавить Бакет_5, который хранит [21, 30]. 
Для этого нам надо взять все данные из бакета2, у которых хэш от 21 до 30 и поместить в новый бакет.

#### Пример с удалением бакета
- Бакет_1 хранит [0, 10]
- Бакет_2 хранит [11, 20]
- Бакет_3 хранит [21, 30]
- Бакет_4 хранит [31, 40]
- Бакет_5 хранит [41, 50]

Мы хотим добавить Бакет_4, который хранит [31, 40]. 
Для этого нам надо решить какой бакет будет иметь больший диапазон.
Выбираем 3. Теперь третий бакет хранит [21, 40]. И мы закидываем все данные из бакет4 в бакет3.

Получается, что из всей системы перемещается только часть данных.

## Методы разрешения коллизий
### Открытая адресация
Вычисляем hash для ключа. Если место в таблице занято -- ищем следующее свободное место.
Чтобы найти следующее место, надо к текущему найденному месту прибавить шаг. Шаг может быть:
- Линейным, прибавляем константу
- Квадратичным, свдигаем на 1, 4, 9 и тд
- Двойное хэширование, шаг вычисляется второй хэш функцией.

Отлично подходит, когда коллизия сама по себе маловероятна. В случае частой коллизии
может произойти кластеризации. Простая реализация.
### Метод цепочек
Дефолтная реализация HashMap в java. Каждый бакет хранит не один элемент, а коллекцию
элементов (например список/дерево). В случае коллизии добавляем элемент в коллекцию.
Количество бакетов может быть фиксированным, более эффективное распределение памяти.
В случае большого количества коллизий, поиск может стать O(N).
### Метод вычеркивания
Объединение метода цепочек и открытой адресации. Принцип хранения как в открытой адресации:
если ячейка занята, ищем следующую свободную. Найдя свободное место, сохраняем элемент в новом месте.
Теперь надо разобраться с цепочкой. Для этого храним массив, где индекс массива это номер ячейки, а значение -> следующий номер ячейки.
То есть, если массив `next[i] == -1` значит есть только один элемент в i-ом бакете.
Если `next[i] != -1`, то следующий элемент находится в `next[i]` позиции. 
