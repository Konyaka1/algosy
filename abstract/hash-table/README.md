## Хэш функция
Задача: отобразить _множетсво_ последовательности байт **любой длины** в _множество_ байт **фиксированный длины**.

По каким критериям можно оценивать hash функцию:
1) Скорость работы. 
2) Вероятность коллизии для произвольного набора значений.
3) Возможность восстановления данных по имеющемуся хэшу.
### Виды
1) Криптографические. Устойчивы к коллизиям и к восстановлению данных из хэша.
2) Некриптографияесие. Общее назначение, высокая скорость и устойчивость к коллизиям. Нет необходимости к защите данных от восстановления по хэшу
3) Контрольные суммы. Простые функции проверяющие случайные ошибки при передаче данных. нет устойчивости к коллизиям и восстановлению/подмены данных
4) Перфектные хеш-функции. Функции на известном наборе входных значений. 100% Отсутствие коллизий.
## JWT vs MD5
MD5 **односторонняя** хэш функция, то есть невозможно восстановить данные из хэша

JWT двусторонняя функция, возможно восстановить данные имея необходимый ключ. Ключ не доступен публично, хранится на сервере выдавшем JWT.

JWT токен это строка, состоящая из `header.payload.signature`
- header -> хранит информацию о типе токена и алгоритме подписи
- payload -> закодированный json с информацией (claims) о пользователе: айди, роли и тд.
- signature -> цифровая подпись. Используется для верификации подлинности токена на сервере
## Consistent hashing
Каждый бакет в таблице отвечает за отрезок хэшей. например от 5 до 17. Все ключи имеющие хэш от 5 до 17 попадут в этот бакет.

При решардинге это позволяет экономить ресурсы на перемещение данных из бакета в бакет.

#### Пример с добавлением бакета
- Бакет_1 хранит [0, 10]
- Бакет_2 хранит [11, 30]
- Бакет_3 хранит [31, 40]
- Бакет_4 хранит [41, 50]

Мы хотим добавить Бакет_5, который хранит [21, 30]. 
Для этого нам надо взять все данные из бакета2, у которых хэш от 21 до 30 и поместить в новый бакет.

#### Пример с удалением бакета
- Бакет_1 хранит [0, 10]
- Бакет_2 хранит [11, 20]
- Бакет_3 хранит [21, 30]
- Бакет_4 хранит [31, 40]
- Бакет_5 хранит [41, 50]

Мы хотим добавить Бакет_4, который хранит [31, 40]. 
Для этого нам надо решить какой бакет будет иметь больший диапазон.
Выбираем 3. Теперь третий бакет хранит [21, 40]. И мы закидываем все данные из бакет4 в бакет3.

Получается, что из всей системы перемещается только часть данных.

## Методы разрешения коллизий
### Открытая адресация
Вычисляем hash для ключа. Если место в таблице занято -- ищем следующее свободное место.
Чтобы найти следующее место, надо к текущему найденному месту прибавить шаг. Шаг может быть:
- Линейным, прибавляем константу
- Квадратичным, свдигаем на 1, 4, 9 и тд
- Двойное хэширование, шаг вычисляется второй хэш функцией.

Отлично подходит, когда коллизия сама по себе маловероятна. В случае частой коллизии
может произойти кластеризации. Простая реализация.
**Note** _при удалении элемена
его нельзя помечать как null, это может разрушить цепочку и сломать всю логику_.
### Метод цепочек
Дефолтная реализация HashMap в java. Каждый бакет хранит не один элемент, а коллекцию
элементов (например список/дерево). В случае коллизии добавляем элемент в коллекцию.
Количество бакетов может быть фиксированным, более эффективное распределение памяти.
В случае большого количества коллизий, поиск может стать O(N). 
### Метод вычеркивания
Объединение метода цепочек и открытой адресации. Принцип хранения как в открытой адресации:
если ячейка занята, ищем следующую свободную. Найдя свободное место, сохраняем элемент в новом месте.
Теперь надо разобраться с цепочкой. Для этого храним массив, где индекс массива это номер ячейки, а значение -> следующий номер ячейки.
То есть, если массив `next[i] == -1` значит есть только один элемент в i-ом бакете.
Если `next[i] != -1`, то следующий элемент находится в `next[i]` позиции. 

## Виды атак на хэш функции
### Атака на коллизии
Найти два разных сообщения, имеющие одинаковый хэш. На входе ничего нет.
### Атака дня рождения
Найти две строки дающие одинаковое значение хэшей. на входе имеем хэш функцию.
### Атака второго прообраза
Найти **второе** сообщение, имеющее такой же хэш. Изначально известно одно сообщение и его хэш.
### Атака на первый прообраз
Найти исходное сообщение по хэшу. На входе имеем хэш и пытаемся найти исходное сообщение.
## Цели атак
1. Сбой в системе проверки подлинности
2. Подделка данных
3. Получение исходных данных
4. Подрыв целостности системы

## Строка Туэ-Морса
Бесконечная бинарная последовательность, составляемая по принципу S = S-prev + NOT(S-prev).
1. t1 = 0
2. t2 = t1 + not t1 = 0 + 1
3. t3 = t2 + not t2 = 01 + 10
4. t4 = t3 + not t3 = 0110 + 1001

## Фильтр блюма
Это вероятностная структура данных, используемая для проверки принадлежности элемента множеству.
Принцип работы: 
1) Фильтр представлен как битовый массив длины m, или как k битовых массивов разной длины.
2) Имеется k различных хэш функций. 
3) При добавлении элемента считаются k хэш значений и для 
каждого значения выставляются соответствующие биты в соответсвующем массиве в 1. 
4) При проверке наличия, считаются все хэш функции и проверяются соотвествующие биты. 
Если хоть один бит равен 0 -- значит элемент _точно_ не существует во множетсве.
Если все равны 1 -- значит элемент _скорее всего_ есть во множестве.
### Плюсы
- Минимальные затраты на память
- Отсутствие ложноотрицательных срабатываний: Если фильтр говорит, что элемента нет в множестве, это точно так.
### Минусы
- Ложноположительные срабатывания, то есть элемент может не существовать во множестве, но фильтр скажет что он есть.
- Отсутствие поддержки удаления в классической реализации

Лучше всего использовать фильтр блюма перед обращением к хэш таблице, чтобы сэкономить время.
Также, если логика поддерживает только операции добавления, или же, операция удаления не приоритетна.


