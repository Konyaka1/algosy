### Solution
```java
class Solution {
    public int maxArea(int[] height) {
        int left = 0;
        int right = height.length - 1;

        int max = Integer.MIN_VALUE;
        while (left < right) {
            int bottom = right - left;
            int minHeight = Math.min(height[left], height[right]);

            int curVolume = bottom * minHeight;
            max = Math.max(max, curVolume);

            while (left < right && minHeight >= height[left]) {
                left++;
            }

            while (left < right && minHeight >= height[right]) {
                right--;
            }
        }

        return max;
    }
}
```

### Time
O(N) -- потому что проходим по всему массиву
### Memory
O(1) -- потому что храним только несколько перменных, количество которых не зависит от длины массива
### Explication
Ставим два указателя в начало и конец и считаем текущий объем.
Текущий обхем равен произведению расстояния между указателями и минимальной высотой.

Далее самый важный момент -- перестановка указателей. Переставляем указатели в том случае, 
если текущий левый/правый меньше либо равен минимальной высоте. То есть при наличии минимальной
высоты равной 10, нас не интересуют высота такая же или меньше этой, потому что объем на след подсчете 
будет 100% меньше текущего объема. Поэтому мы передвигаем _левый_ указатель пока он _меньше **правого** указателя_ и 
пока высота левой стенки не будет больше текущей минимальной высоты. Аналогично для правого: 
перемещаем правй указатель, пока он больше левого и пока правая стенка не превысит текущую минимальную высоту.

Таким образом мы считаем объем только тех стенок, которые выше текущего минимума.
