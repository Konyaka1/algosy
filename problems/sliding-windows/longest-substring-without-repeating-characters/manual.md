### Solution
```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int l = 0;
        int r = -1;

        int maxLength = 0;
        Set<Character> set = new HashSet<>();

        while (l < s.length()) {
            while (r + 1 < s.length() && set.add(s.charAt(r + 1))) {
                r = r + 1;
            }

            maxLength = Math.max(maxLength, set.size());

            set.remove(s.charAt(l));
            l = l + 1;
        }

        return maxLength;
    }
}
```
### Time
O(N) -- потому что проходим по всей строке
### Memory
O(K) -- максимально храним самую длинную подстроку, K -- длина подстроки самой длинной
### Explication
Применяем паттерн пересекающихся окон. Двигаем правый, пока это новый уникальный символ.
Как только мы нашли повторение -- удаляем символ по левому указателю и двигаем левый указатель.
Продолжаем до успеха. 

**Важно** -- может возникнуть ситуация когда l > r. Это значит что мы
имеем пустую подстроку, и сет будет пустым. Разница между l и r в таком случае не больше 1.
Следовательно, перед след итерацией мы имеем `l = x`, `r = x - 1` и пустой `set` текущей подстроки.
На этой итерации мы в сет добавим элемент по индексу `r + 1`, и l станет равным r и сет будет из одного элемента.

