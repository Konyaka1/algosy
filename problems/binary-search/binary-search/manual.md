### Solution
Left based. Last вхождение
```java
class Solution {
    public int search(int[] nums, int target) {
        int l = 0;
        int r = nums.length;

        while (r - l > 1) {
            int m = (l + r) / 2;
            if (this.isGood(nums[m], target)) {
                l = m;
            } else {
                r = m;
            }
        }

        if (nums[l] == target) {
            return l;
        } else {
            return -1;
        }

    }

    private boolean isGood(int x, int target) {
        return x <= target;
    }
}
```
Right based. First вхождение
```java
class Solution {
    public int search(int[] nums, int target) {
        int l = -1;
        int r = nums.length - 1;
        
        while (r - l > 1) {
            int m = (l + r) / 2;
            if (this.isGood(nums[m], target)) {
                l = m;
            } else {
                r = m;
            }
        }
        
        if (nums[r] == target) {
            return r;
        } else {
            return -1;
        }
        
    }
    
    private boolean isGood(int x, int target) {
        return x < target;
    }
}
```
### Time
O(log N) -- каждый раз мы делим на два, и кол-во операций уменьшается в двое
### Memory
O(1) -- нет нужды в доп памяти зависящей от длины массива
### Explication
Делаем бинарный поиск. Идея в том, чтобы разделить массив на две части,
в одной хранятся элементы подходящие под условие, в другой элементы неподходящие.
Например в примере ниже элементы отсортированы по возрастанию, мы ищем x3. Идея в том,
чтобы поставить указатели так, чтобы `l` указывал на результат.
Таким образом, `l` является _последним хорошим_ элементом, а `r` указывает на
_первый плохой_ элемент. Таким образом мы найдем последнее вхождение x3, если их было много.
Начальная позиция, функция сравнения `xi <= target`.
```text
 l
[x0, x1, x2, x3, x3, x4, x5]
                             r
```
После работы алгоритма
```text
                  l
[x0, x1, x2, x3, x3, x4, x5]
                      r
```
Таким образом левый указывает последний элемент меньше либо равный таргету. А правый указывает на 
первый элемент не подходящий. Мы можем найти последнее вхождение элемента в массиве.

Аналогичное действия для поиска первого вхождения
Начальная позиция, функция сравнения `xi < target`.
```text
 l
   [x0, x1, x2, x3, x3, x4, x5]
                             r
```
После работы алгоритма
```text
         l
[x0, x1, x2, x3, x3, x4, x5]
             r
```
Для использования бинарного поиска, нам нужны два условия:
#### 1. Функция сравнения
Необходима функция от двух аргументов `xi` и `target`, где `xi` это любой элемент
множества, а `target` это элемент для поиска, такая что:
```text
                -1, если xi < target
f(xi, target) =  0, если xi == target
                 1, если xi > target
```
#### 2. Монотонное множество
Необходимо чтобы применяя функцию выше к каждому элементу входного
множества на выходе мы получили монотонно убывающую или монотонно возрастающую последовательность.
То есть для любого `x1` и `x2`, где `x1` < `x2`, выполняется условие 
`f(x1) <= f(x2)` или `f(x1) >= f(x2)`.